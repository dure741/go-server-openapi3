/*
 * 用户组管理API
 *
 * 这是一个对用户组进行创建、修改、检索、和删除的API
 *
 * API version: 3.11
 * Contact: huanghui@zdns.cn
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"api3server/staticweb"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"regexp"
	"strings"

	assetfs "github.com/elazarl/go-bindata-assetfs"

	"github.com/syllabix/swagserver/option"
	"github.com/syllabix/swagserver/theme"

	"github.com/getkin/kin-openapi/openapi3filter"
	"github.com/gorilla/mux"
	"github.com/syllabix/swagserver"
)

type Route struct {
	Name        string
	Method      string
	Pattern     string
	HandlerFunc http.HandlerFunc
}

type Routes []Route

func NewRouter() *mux.Router {
	router := mux.NewRouter().StrictSlash(true)
	for _, route := range routes {
		var handler http.Handler
		handler = route.HandlerFunc
		handler = Logger(handler, route.Name)

		router.
			Methods(route.Method).
			Path(route.Pattern).
			Name(route.Name).
			Handler(handler)
	}

	//swagger ui使用，先运行swaggerui
	router.PathPrefix("/apidoc").Handler(http.StripPrefix("/apidoc", http.FileServer(&assetfs.AssetFS{
		Asset:    staticweb.Asset,
		AssetDir: staticweb.AssetDir,
		//AssetInfo:	staticweb.AssetInfo,
	})))
	router.Use(setupGlobalMiddlewareSwagger)
	//swagger json返回，(需要通过验证)
	//router.PathPrefix("/swagger.json").HandlerFunc(SwaggerJson)
	//添加验证，后进行validate
	router.Use(openApiRulesValidation)
	return router
}

func Index(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Hello World!")
}

var routes = Routes{
	Route{
		"Index",
		"GET",
		"/",
		Index,
	},

	Route{
		"UserGroupsGet",
		strings.ToUpper("Get"),
		"/user_groups",
		UserGroupsGet,
	},

	Route{
		"UserGroupsIdDelete",
		strings.ToUpper("Delete"),
		"/user_groups/{id}",
		UserGroupsIdDelete,
	},

	Route{
		"UserGroupsPost",
		strings.ToUpper("Post"),
		"/user_groups",
		UserGroupsPost,
	},

	//保留，此声明route会被validate检测
	Route{
		"SwaggerJson",
		strings.ToUpper("Get"),
		"/swagger.json",
		SwaggerJson,
	},
}

func openApiRulesValidation(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

		fmt.Println("Start validate " + r.RequestURI)
		router := openapi3filter.NewRouter().WithSwaggerFromFile("./api/swagger.yaml")
		ctx := context.Background()
		route, pathParams, isempty := router.FindRoute(r.Method, r.URL)
		if isempty != nil {
			fmt.Println(isempty)
		}
		// Validate request
		requestValidationInput := &openapi3filter.RequestValidationInput{
			Request:    r,
			PathParams: pathParams,
			Route:      route,
		}
		if err := openapi3filter.ValidateRequest(ctx, requestValidationInput); err != nil {
			msg := err.Error()
			e := &ErrorMessage{
				ErrAPI: route.Path,
			}
			fmt.Println(getErrorFirstLine(msg))
			decodeerr := e.Decode(msg, "./errmsgdef.json")
			fmt.Println(decodeerr)
			http.Error(w, decodeerr.Error(), http.StatusBadRequest)
			return
		}
		next.ServeHTTP(w, r)
		//openapi3filter.ValidationHandler
	})
}

//swagger ui 中间件(搭配swagger ui 前端使用)
func setupGlobalMiddlewareSwagger(handler http.Handler) http.Handler {
	swagserve := swagserver.New(
		option.Path("/apidoc"),
		option.SwaggerSpecURL("/swagger.json"),
		option.Theme(theme.Standard),
	)
	return swagserve(handler)
}

// # 错误信息：
// ## 参数
// ### query
// ---
// - 不匹配正则表达式
// ` Parameter` 'page_num' in ` query` has an error: JSON string doesn't match the ` regular expression` '^x-'
// - 不合规值
// ` Parameter` 'page_num' in ` query` has an error: value ssd: an invalid integer: strconv.ParseFloat: parsing "ssd": invalid syntax
// - 数值超限
// ` Parameter` 'page_size' in ` query` has an error: ` Number must be most` 23
// ` Parameter` 'page_size' in ` query` has an error: ` Number must be at least` 10
// - 缺失查询参数
// ` Parameter` 'page_num' in ` query` has an error: ` must have a value`: must have a value
// ### path
// - 不合规值
// ` Parameter` 'id' in ` path` has an error: value jfije: an invalid integer: strconv.ParseFloat: parsing "jfije": invalid syntax
// - 数值超限
// ` Parameter` 'id' in ` path` has an error: ` Number must be at least` 10
// ### header
// ### cookie
// ## 请求体
// ### body
// ---
// - 键值缺失
// ` Request body` has an error: doesn't match the schema: Error at "/usergroup_name":` Property` 'usergroup_name' ` is missing`
// - 不匹配正则表达式
// ` Request body` has an error: doesn't match the schema: Error at "/usergroup_name":JSON string doesn't match the ` regular expression` '^x-'
// - 值不为字符串
// ` Request body` has an error: doesn't match the schema: Error at "/current_user":` Field must be set to` string or not be present
// - 值不为integer
// ` Request body` has an error: doesn't match the schema: Error at "/current_user":` Field must be set to` integer or not be present
// - 数值超限
// ` Request body` has an error: doesn't match the schema: Error at "/current_user":` Number must be at least` 10
// ` Request body` has an error: doesn't match the schema: Error at "/current_user":` Number must be most` 23
// ## 认证策略
// 暂调研深入

//getErrorFirstLine 获取信息的第一行
func getErrorFirstLine(all string) string {
	firstline := strings.Split(all, "\n")[0]
	return firstline
}

//ErrorMessage 是用于储存从错误信息中解析到的关键内容
type ErrorMessage struct {
	ErrAPI   string      //ErrAPI 出错的接口
	Location string      //Location 出错的位置 <Paremeter><Request body>
	ErrorKey string      //ErrorKey 出错的字段
	Reason   string      //Reason 出错的理由
	Err      interface{} //Err 自定义的错误信息，通过解析获得，主要返回内容
}

//Error 用于ErrorMessage实现error接口
func (e *ErrorMessage) Error() string {
	return fmt.Sprintf("\"error\": \"%v\"", e.Err)
}

//Decode 用于ErrorMessage解析提供的配置文件，获取错误信息
func (e *ErrorMessage) Decode(srcerr string, path string) error {
	//原先的错误信息长度为0则返回nil
	if len(srcerr) == 0 {
		return nil
	}
	//解析错误信息
	decodeerr := e.DecodeSrcError(srcerr)
	if decodeerr != nil {
		return decodeerr
	}
	fmt.Println(e.ErrAPI, e.Location, e.ErrorKey, e.Reason)

	//解析错误信息配置文件
	errconfig, readErr := ioutil.ReadFile(path)
	if readErr != nil {
		return readErr
	}
	errconfigjson := make(map[string]interface{})
	unmarshalErr := json.Unmarshal(errconfig, &errconfigjson)
	if unmarshalErr != nil {
		return unmarshalErr
	}
	e.Err = errconfigjson[e.Location+e.Reason]
	return e
}

//DecodeSrcError 用于ErrorMessage解析原来的错误信息
func (e *ErrorMessage) DecodeSrcError(srcerr string) error {
	hasAnParamError := regexp.MustCompile(" has an error: ")
	//确定是参数存在错误，进行后续匹配
	if len(hasAnParamError.FindAllString(srcerr, -1)) >= 1 {
		positionMsg := hasAnParamError.Split(srcerr, 2)
		//错误位置匹配
		inParameter := regexp.MustCompile("Parameter '")
		inBody := regexp.MustCompile("Request body")
		inPath := regexp.MustCompile("' in path")
		inQuery := regexp.MustCompile("' in query")
		//Parameter 和 request body公用
		doesntMatchRegExp := regexp.MustCompile("doesn't match the regular expression")
		overLimit := regexp.MustCompile("Number must be")
		//Parameter 错误匹配
		invalidType := make(map[string]*regexp.Regexp)
		keyMissing := make(map[string]*regexp.Regexp)
		invalidType["parameter"] = regexp.MustCompile("invalid syntax")
		keyMissing["parameter"] = regexp.MustCompile("must have a value")
		//Body 错误匹配
		invalidType["body"] = regexp.MustCompile("Field must be set to")
		keyMissing["body"] = regexp.MustCompile("Property '.+' is missing")
		//判断出错的位置path|query
		if len(inParameter.FindAllString(positionMsg[0], -1)) == 1 {
			if inPath.MatchString(positionMsg[0]) {
				e.Location = "Path"
				e.ErrorKey = inPath.ReplaceAllString(inParameter.ReplaceAllString(positionMsg[0], ""), "")
			} else if inQuery.MatchString(positionMsg[0]) {
				e.Location = "Query"
				e.ErrorKey = inQuery.ReplaceAllString(inParameter.ReplaceAllString(positionMsg[0], ""), "")
			} else {
				return errors.New("Error in other location in parameter")
			}
			//判断错误类型
			location := "parameter"
			switch {
			case doesntMatchRegExp.MatchString(positionMsg[1]):
				e.Reason = "MatchRegularExpError"
			case overLimit.MatchString(positionMsg[1]):
				e.Reason = "OverLimit"
			case invalidType[location].MatchString(positionMsg[1]):
				e.Reason = "InvalidType"
			case keyMissing[location].MatchString(positionMsg[1]):
				e.Reason = "KeyMissing"
			default:
				return errors.New("Unconsitered error type")
			}

			//判断出错的位置body
		} else if len(inBody.FindAllString(positionMsg[0], -1)) == 1 {
			e.Location = "Body"
			e.ErrorKey = strings.Split(positionMsg[1], "\"")[1]
			//判断错误类型
			location := "body"
			switch {
			case doesntMatchRegExp.MatchString(positionMsg[1]):
				e.Reason = "MatchRegularExpError"
			case overLimit.MatchString(positionMsg[1]):
				e.Reason = "OverLimit"
			case invalidType[location].MatchString(positionMsg[1]):
				e.Reason = "InvalidType"
			case keyMissing[location].MatchString(positionMsg[1]):
				e.Reason = "KeyMissing"
			default:
				return errors.New("Unconsitered error type")
			}
		} else {
			return errors.New("Source string has more than 1 \"Request body '\" or \"Paramenter '\"")
		}
	} else {
		return errors.New("Source string has more than 1 \" has an error: \"")
	}
	return nil
}
